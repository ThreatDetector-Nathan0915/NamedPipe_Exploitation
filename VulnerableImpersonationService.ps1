Add-Type @"
using System;
using System.IO;
using System.IO.Pipes;
using System.Security.AccessControl;
using System.Security.Principal;

public class NamedPipeServer
{
    public static NamedPipeServerStream CreateNamedPipe(string pipeName)
    {
        var pipeSecurity = new PipeSecurity();
        pipeSecurity.AddAccessRule(new PipeAccessRule(
            new SecurityIdentifier(WellKnownSidType.WorldSid, null),
            PipeAccessRights.FullControl, AccessControlType.Allow));
        return new NamedPipeServerStream(pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Byte, PipeOptions.None, 4096, 4096, pipeSecurity);
    }

    public static void ImpersonateClient(NamedPipeServerStream pipe)
    {
        if (pipe.IsConnected)
        {
            pipe.RunAsClient(() => { });
        }
        else
        {
            throw new InvalidOperationException("No client is connected to the pipe.");
        }
    }
}
"@

# Define the name of the pipe
$pipeName = "VulnerablePipe"

# Create the named pipe with appropriate security attributes
$pipe = [NamedPipeServer]::CreateNamedPipe($pipeName)

if ($pipe -eq $null) {
    Write-Host "Failed to create named pipe."
    exit
}

Write-Host "Vulnerable service created named pipe: \\.\pipe\$pipeName"
$pipe.WaitForConnection()
Write-Host "Client connected to named pipe."

$streamReader = New-Object System.IO.StreamReader($pipe)

while ($true) {
    try {
        # Read a message from the client
        $message = $streamReader.ReadLine()
        if ($message -ne $null) {
            Write-Host "Vulnerable service received: $message"

            # Impersonate the client for this command
            try {
                [NamedPipeServer]::ImpersonateClient($pipe)
                Write-Host "Impersonation successful."

                # Execute the command
                Invoke-Expression $message
            } catch {
                Write-Host "Error during impersonation: $_"
            } finally {
                # Revert impersonation
                $pipe.RunAsClient({ [System.Security.Principal.WindowsIdentity]::GetCurrent().ImpersonationLevel -eq [System.Security.Principal.TokenImpersonationLevel]::None })
                Write-Host "Impersonation reverted."
            }
        }
    } catch {
        Write-Host "Error: $_"
        break
    }
    Start-Sleep -Milliseconds 100
}

$pipe.Disconnect()
$pipe.Close()
Write-Host "Named pipe closed."
